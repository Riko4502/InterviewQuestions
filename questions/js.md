<h3>
  <span>JavaScript:</span>
</h3>

**Типы данных в JavaScript?**

- Примитивные типы данных: string (строка), number (число), boolean (логический тип), null (отсутствие значения), undefined (значение не определено), symbol (уникальный и неизменяемый идентификатор).
- Ссылочные типы данных: object (объект), включая массивы, функции и объекты Date.

**Разница между == и === (нестрогое/строгое равенство)?**

- == выполняет нестрогое сравнение, преобразуя типы данных при необходимости.
- === выполняет строгое сравнение, сравнивая значения и типы данных без преобразования.

**Что такое Strict mode в JavaScript?**

Strict mode — это режим, в котором код выполняется в более строгом режиме, обеспечивая более точную семантику языка.

Включение строгого режима осуществляется с помощью директивы "use strict"; в начале скрипта или функции.
Строгий режим активизирует некоторые новые возможности языка, исправляет ошибки и запрещает использование некоторых потенциально опасных конструкций.

**Разница между function declaration и function expression?**

Function declaration (объявление функции) начинается с ключевого слова function и имеет имя функции.
Function expression (функциональное выражение) создается путем присваивания функции переменной или использования ее в качестве значения выражения.
Основная разница заключается в том, что function declarations создаются до выполнения кода (во время поднятия), а function expressions создаются во время выполнения кода.

**Разница между null и undefined?**

null используется для обозначения отсутствия значения или пустого объекта.
undefined используется для обозначения переменной, которая была объявлена, но ей не было присвоено значения, или для параметра функции, которому не было передано значение.

**Типы таймеров в JavaScript?**

setTimeout выполняет функцию один раз через указанный интервал времени.
setInterval выполняет функцию периодически через указанный интервал времени.
requestAnimationFrame используется для выполнения анимации и планирования обновлений экрана на основе частоты обновления браузера.

**Что такое поднятие (Hoisting)?**

Поднятие — это механизм в JavaScript, который перемещает объявления переменных и функций вверх в их область видимости перед выполнением кода.
В результате поднятия можно обращаться к переменным и функциям до их фактического объявления в коде.

**Что такое область видимости (Scope)?**

Область видимости определяет доступность переменных, объектов и функций в определенной части кода.
Глобальная область видимости — это доступность по всему коду.
Локальная область видимости — это доступность только внутри определенной функции или блока кода.

**Разница между var, let и const?**

var — ключевое слово для объявления переменных со значением, видимым внутри функции или глобальной области видимости.
let — ключевое слово для объявления переменных со значением, видимым внутри блока кода, в котором они объявлены.
const — ключевое слово для объявления переменных со значением, которое не может быть изменено после присваивания. Константы должны быть инициализированы при объявлении.

**Что такое замыкание (Closure)?**

Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена.
Замыкание позволяет функции сохранять доступ к переменным из своего внешнего лексического окружения, даже после того, как это окружение было выполнено.

**Что обозначает this в JavaScript?**

Ключевое слово this в JavaScript ссылается на текущий контекст выполнения.
Значение this зависит от того, как функция была вызвана: как метод объекта, как функция конструктора, как метод объекта с использованием call или apply, или в глобальной области видимости.

**Что такое функции высшего порядка (Higher Order Functions)?**

Функции высшего порядка — это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результата.
Функции высшего порядка позволяют создавать абстракции и компоненты для повторного использования кода.

**Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?**

Для преобразования любого типа данных в булевый (логический) тип можно использовать логическое отрицание !!.
Ложные (falsy) значения в JavaScript: false, 0, "" (пустая строка), null, undefined, NaN.

**Методы строк в JavaScript?**

- length — возвращает длину строки.
- charAt(index) — возвращает символ по указанному индексу.
- concat(...strings) — объединяет строки.
- indexOf(searchValue[, fromIndex]) — возвращает индекс первого вхождения заданного значения.
- substring(startIndex[, endIndex]) — возвращает подстроку с указанными индексами начала и конца.
и другие методы: toUpperCase(), toLowerCase(), split(), trim(), replace(), startsWith(), endsWith() и т.д.

**Методы массивов в JavaScript?**

- length — возвращает длину массива.
- push(...items) — добавляет элементы в конец массива.
- pop() — удаляет и возвращает последний элемент массива.
- shift() — удаляет и возвращает первый элемент массива.
- unshift(...items) — добавляет элементы в начало массива.
- concat(...arrays) — объединяет массивы.
и другие методы: join(), slice(), splice(), reverse(), sort(), indexOf(), lastIndexOf(), forEach(), map(), filter(), reduce() и т.д.


**Что такое чистая функция?**

Чистая функция — это функция, которая возвращает результат только на основе своих аргументов без побочных эффектов.
Чистая функция не изменяет внешнее состояние и не взаимодействует с внешними ресурсами.

**Разница между .forEach() и .map()?**

.forEach() вызывает переданную функцию для каждого элемента массива, но не возвращает новый массив.
.map() вызывает переданную функцию для каждого элемента массива и возвращает новый массив, состоящий из результатов вызовов функции.

**Разница между .call(), .apply() и bind()?**

.call() и .apply() используются для вызова функции с явным указанием контекста (значения this) и передачей аргументов.
Разница между .call() и .apply() заключается в способе передачи аргументов: .call() принимает аргументы через запятую, а .apply() принимает аргументы в виде массива.
.bind() создает новую функцию, привязывая указанный контекст (значение this) и, при необходимости, предварительно заданные аргументы.

**Почему в JS функции называют объектами первого класса?**

Потому, что они могут быть:
- Присвоены переменной.
- Использованы как аргументы для других функций.
- Возвращены из других функций.
- Хранены в структурах данных, например, в массивах или объектах.

**Как определить наличие свойства в объекте?**

Для проверки наличия свойства в объекте можно использовать оператор in или метод hasOwnProperty().

Пример с использованием оператора in:

```
const obj = { prop: 'value' };

if ('prop' in obj) {
  console.log('Свойство "prop" существует в объекте');
}
```

Пример с использованием метода **hasOwnProperty()**:

```
const obj = { prop: 'value' };

if (obj.hasOwnProperty('prop')) {
  console.log('Свойство "prop" существует в объекте');
}
```

**Что такое IIFE?**

IIFE (Immediately Invoked Function Expression) — это функция, которая вызывается немедленно после своего определения. Она часто используется для создания локальной области видимости и изоляции переменных от глобального контекста. IIFE обычно создается в виде анонимной функции, которая затем вызывается с помощью оператора вызова ().

Пример IIFE:

```
(function() {
  // Код IIFE
})();

```

**Что такое псевдомассив arguments?**

Псевдомассив arguments — это объект, доступный внутри функции, который содержит все аргументы, переданные функции при её вызове. arguments имеет свойства, похожие на элементы массива, но он не является полноценным массивом, поскольку не имеет методов массива.

**Разница между host-объектами и нативными объектами?**

В контексте JavaScript host-объекты — это объекты, предоставляемые средой выполнения (например, браузером или Node.js) и доступные в глобальной области видимости. Они могут включать объекты, такие как window (в браузере) или global (в Node.js), а также другие объекты, предоставляемые средой выполнения.

Нативные объекты, с другой стороны, это объекты, предоставляемые самим языком JavaScript. Они включают в себя объекты, такие как Array, Object, Function и т.д.

**Почему результат сравнения 2х объектов это false?**

Результат сравнения двух объектов ({}) будет false, потому что операторы сравнения (== и ===) для объектов сравнивают ссылки на объекты, а не их содержимое. Два объекта с разными ссылками будут считаться разными объектами, даже если они имеют одинаковую структуру и значения свойств.

**Что такое прототипное наследование? Как создать объект без прототипа?**

Прототипное наследование — это механизм наследования в JavaScript, где объект может наследовать свойства и методы от другого объекта, называемого прототипом. Прототипы в JavaScript образуют цепочку, которая позволяет объектам наследовать свойства и методы от прототипов своих прототипов.

Для создания объекта без прототипа можно использовать функцию Object.create(null). Это создаст объект, у которого нет прототипа и не наследует свойства и методы от других объектов.

Пример создания объекта без прототипа:

```
const objWithoutPrototype = Object.create(null);
```

**Почему расширение нативных JavaScript-объектов это плохая практика?**

Расширение нативных JavaScript-объектов, добавление новых методов или свойств к встроенным объектам (например, Array, String, Object), считается плохой практикой по нескольким причинам:

- Возможность конфликтов имён: расширение нативных объектов может привести к конфликтам имён с будущими версиями языка или другими библиотеками.
- Непредсказуемое поведение: расширение нативных объектов может изменить их поведение в неожиданный способ, что может затруднить отладку и поддержку кода.
- Портабельность: код, который расширяет нативные объекты, может не работать в других средах выполнения или старых версиях JavaScript.

**Что такое NaN? Как определить, что значение равно NaN?**

NaN (Not-a-Number) — это специальное значение в JavaScript, которое указывает на то, что результат математической операции не является числом. Например, деление нуля на ноль или попытка преобразования некорректной строки в число может дать NaN.

Чтобы определить, что значение равно NaN, можно использовать функцию isNaN() или оператор Number.isNaN().

Пример использования isNaN():

```
isNaN(NaN); // true
isNaN(10); // false
```
Пример использования Number.isNaN():

```
Number.isNaN(NaN); // true
Number.isNaN(10); // false
```

**Что такое объектная обертка (Wrapper Objects)?**

Объектные обертки (Wrapper Objects) в JavaScript предоставляют возможность работать с примитивными типами (Number, String, Boolean) как с объектами. Это означает, что к примитивным значениям можно применять методы, которые предоставляют объектные обертки.

Например:

```
const str = 'Hello';
const strWrapper = new String(str);

console.log(str.length); // 5
console.log(strWrapper.length); // 5
```

В данном примере strWrapper является объектной оберткой для примитивного значения строки str.

**Как в JavaScript создать объект?**

В JavaScript объекты можно создать с помощью литерала объекта {} или с использованием конструктора new Object().

Примеры:

```
// Литерал объекта
const obj1 = {};

// Конструктор Object()
const obj2 = new Object();
```

Можно также создать объект с начальными свойствами и значениями с помощью литерала объекта или метода Object.create().

Примеры:

```
// Литерал объекта с начальными свойствами
const obj3 = { prop1: 'value1', prop2: 'value2' };

// Object.create()
const obj4 = Object.create(null);
```

**Для чего используется ключевое слово new?**

Ключевое слово new используется для создания экземпляра объекта, используя конструктор функцию. При использовании new, функция-конструктор вызывается с новым пустым объектом в качестве контекста выполнения (this), и этот объект становится результатом операции new.

Пример:

```
function Person(name) {
  this.name = name;
}

const john = new Person('John');
console.log(john.name); // 'John'
```

В приведенном примере **new Person('John')** создает новый объект, на который ссылается **this** внутри **функции-конструктора Person**, и устанавливает свойство name этого объекта в **'John'**.

**Операторы «И» и «ИЛИ» (&& и ||)?**

Оператор && (логическое И) возвращает первый операнд, если он приводится к логическому значению false, в противном случае возвращает второй операнд. Оператор || (логическое ИЛИ) возвращает первый операнд, если он приводится к логическому значению true, в противном случае возвращает второй операнд.

Примеры:

```
const a = 10;
const b = 20;
const c = null;
const d = 'Hello';

console.log(a && b); // 20, так как оба операнда истинны
console.log(a && c); // null, так как первый операнд ложный
console.log(c && d); // null, так как первый операнд ложный

console.log(a || b); // 10, так как первый операнд истинный
console.log(a || c); // 10, так как первый операнд истинный
console.log(c || d); // 'Hello', так как оба операнда ложные
```

Обратите внимание, что операторы && и || выполняют ленивую оценку, что означает, что второй операнд не вычисляется, если его значение не влияет на результат операции.

**Для чего используется оператор двойного отрицания (!!)?**

Оператор двойного отрицания (!!) используется для преобразования значения в логический тип данных (true или false). Он применяется к значению и выполняет следующие действия:

Если значение является ложным (например, false, null, undefined, 0, NaN, пустая строка), то оператор !! преобразует его в false.
Если значение является истинным (любое значение, отличное от ложных значений), то оператор !! преобразует его в true.
При использовании оператора двойного отрицания, результатом будет всегда логическое значение true или false. Это может быть полезно, когда необходимо проверить и привести значение к логическому типу данных.

Примеры:

```
console.log(!!true);      // true
console.log(!!false);     // false
console.log(!!0);         // false
console.log(!!1);         // true
console.log(!!null);      // false
console.log(!!undefined); // false
console.log(!!'');        // false
console.log(!!'hello');   // true
console.log(!!{});        // true
console.log(!![]);        // true
```

В примере выше, оператор !! используется для преобразования различных значений в логические значения.

**Для чего используется оператор остатка (%)?**

Оператор остатка (%) используется для получения остатка от деления двух чисел. Например, выражение a % b вернет остаток от деления числа a на число b. Оператор остатка полезен, когда требуется выполнить определенные действия в зависимости от четности или нечетности числа или когда нужно проверить делимость одного числа на другое.

**Как проверить, является ли значение массивом?**

В JavaScript можно использовать метод **Array.isArray()** для проверки, является ли значение массивом. Этот метод возвращает **true**, если переданное значение является массивом, и **false** в противном случае. 
Пример использования:

```
const value = [1, 2, 3];
console.log(Array.isArray(value)); // true

const anotherValue = 'Hello';
console.log(Array.isArray(anotherValue)); // false
```

**Как работает boxing/unboxing в JavaScript?**

Boxing и unboxing в JavaScript связаны с преобразованием примитивных типов данных в объекты и обратно.

Boxing (также называемый "упаковкой") происходит, когда примитивное значение (например, число, строка или булево значение) используется как объект. JavaScript автоматически создает объект-обертку для примитивного значения, чтобы можно было вызывать методы и использовать свойства объекта.

Unboxing (также называемый "распаковкой") происходит, когда объект-обертка преобразуется обратно в примитивное значение. JavaScript автоматически извлекает значение из объекта-обертки, когда это значение требуется для выполнения операции.

Примеры:

```
// Boxing
const number = 42; // примитивное число
const numberObject = new Number(number); // объект-обертка

console.log(number.toFixed(2)); // Метод toFixed() работает благодаря автоматическому boxing

// Unboxing
const stringObject = new String('Hello'); // объект-обертка
const string = stringObject.valueOf(); // распаковка в примитивное значение

console.log(string.toUpperCase()); // Метод toUpperCase() работает после распаковки
```

**Что такое мемоизация? Реализуйте базовую логику функции для мемоизации?**

Мемоизация - это оптимизационная техника, которая заключается в сохранении результатов выполнения функции для заданных входных данных, чтобы избежать повторных вычислений при последующих вызовах функции с теми же входными данными. Это особенно полезно, когда функция является ресурсоемкой или часто вызывается с одними и теми же аргументами.

Вот пример базовой реализации функции для мемоизации:

```
function memoize(func) {
  const cache = {}; // Кеш для хранения результатов выполнения функции

  return function (...args) {
    const key = JSON.stringify(args); // Создаем ключ на основе аргументов функции

    if (cache[key]) {
      return cache[key]; // Возвращаем сохраненное значение из кеша
    }

    const result = func.apply(this, args); // Выполняем функцию

    cache[key] = result; // Сохраняем результат выполнения в кеше

    return result; // Возвращаем результат
  };
}

// Пример использования

function calculateFactorial(n) {
  console.log(`Calculating factorial of ${n}...`);
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * calculateFactorial(n - 1);
}

const memoizedFactorial = memoize(calculateFactorial);

console.log(memoizedFactorial(5)); // Первый вызов - вычисляется и кешируется
console.log(memoizedFactorial(5)); // Второй вызов - результат берется из кеша
console.log(memoizedFactorial(3)); // Новый аргумент - вычисляется и кешируется
console.log(memoizedFactorial(3)); // Результат берется из кеша
```



**Разница между оператором in и методом .hasOwnProperty()?**

Оператор **in** и метод **.hasOwnProperty()** в JavaScript используются для проверки наличия свойства в объекте, но имеют некоторые различия.

Оператор **in** проверяет наличие свойства не только в самом объекте, но и в его прототипе. Если свойство найдено в прототипе, оператор **in** вернет **true**. 

Пример:

```
const obj = { foo: 'bar' };

console.log('foo' in obj); // true

// Создаем объект с прототипом obj
const objWithPrototype = Object.create(obj);
console.log('foo' in objWithPrototype); // true
```

Метод **.hasOwnProperty()** проверяет наличие свойства только в самом объекте, игнорируя его прототип. Если свойство найдено в прототипе, **.hasOwnProperty()** вернет **false**. 

Пример:

```
const obj = { foo: 'bar' };

console.log(obj.hasOwnProperty('foo')); // true

// Создаем объект с прототипом obj
const objWithPrototype = Object.create(obj);
console.log(objWithPrototype.hasOwnProperty('foo')); // false
```

**Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?**

Глубокая (deep) копия объекта создает полностью независимую копию, включая все вложенные объекты и массивы. Изменения, внесенные в оригинальный объект или его копию, не будут влиять друг на друга.

Поверхностная (shallow) копия объекта создает новый объект, но ссылки на вложенные объекты и массивы остаются общими для оригинала и его копии. Изменения внутри вложенных объектов или массивов будут видны как в оригинале, так и в его копии.

Вот примеры, как можно создать глубокую и поверхностную копии объекта:

Глубокая копия:

```
const obj = { a: 1, b: { c: 2 } };

// Способ 1: Рекурсивное клонирование объекта
const deepCopy1 = JSON.parse(JSON.stringify(obj));

// Способ 2: Использование библиотеки lodash
const deepCopy2 = _.cloneDeep(obj);
```

Поверхностная копия:

```
const obj = { a: 1, b: { c: 2 } };

// Способ 1: Использование Object.assign()
const shallowCopy1 = Object.assign({}, obj);

// Способ 2: Использование расширения объекта
const shallowCopy2 = { ...obj };
```

**Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?**

Цепочка вызовов функций (chaining) - это подход, при котором методы вызываются последовательно на одном объекте, а результат каждого метода становится доступным для вызова следующего метода. Это позволяет сократить код и сделать его более читабельным.

Для реализации цепочки вызовов функций, каждый метод должен возвращать объект, на котором он вызывается. Это достигается путем возврата ссылки на текущий объект (this) в конце каждого метода.

Вот пример, демонстрирующий реализацию цепочки вызовов функций:

```
class Calculator {
  constructor() {
    this.value = 0;
  }

  add(num) {
    this.value += num;
    return this; // Возвращаем ссылку на текущий объект
  }

  subtract(num) {
    this.value -= num;
    return this; // Возвращаем ссылку на текущий объект
  }

  multiply(num) {
    this.value *= num;
    return this; // Возвращаем ссылку на текущий объект
  }

  divide(num) {
    this.value /= num;
    return this; // Возвращаем ссылку на текущий объект
  }
}

const calculator = new Calculator();
const result = calculator.add(5).multiply(2).subtract(3).divide(2);
console.log(result.value); // 4
```

В этом примере можно видеть, как методы add(), multiply(), subtract(), divide() последовательно вызываются на объекте calculator, а результат каждого метода становится доступным для вызова следующего метода.

**Что такое необъявленная переменная?**
**Как передаются параметры в функцию: по ссылке или по значению?**
**Что такое прототип объекта в JavaScript?**
**Как работает метод Object.create()?**
**Разниц между Object.freeze() и Object.seal()?**
**Разница между методами .slice() и .splice()?**
**Как работают методы .find(), .findIndex() и .indexOf()?**
**Плюсы и минусы использования use strict?**
**Разница между методами .push(), .pop(), .shift() и .unshift()?**
**Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?**
**Типы всплывающих окон в JavaScript?**
**Типы объектов JavaScript?**
**Парадигмы программирования в JavaScript?**
**Типы ошибок в JavaScript?**
**Разница между typeof и instanceof?**
**JavaScript статически, или динамически типизированный язык?**
**Что такое регулярное выражение (Regular Expression)?**
**Что такое рекурсия?**
**Что такое прототип (Prototype) объекта?**
**Какие методы используются в регулярных выражениях?**
**Что такое полифил (polyfill)?**
**Что такое switch/case? Правила использования switch/case?**
**Типы функций по способности принимать другие функции?**
**Что такое выражения (expression) и инструкции (statement) в JavaScript?**
**Разница между .some() и .every()?**
**Как сгенерировать случайное число в JavaScript?**
**Типы операторов в JavaScript?**
**Разница между параметром и аргументом функции?**
**Правила задания имён для переменных и функций в JavaScript?**
**Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?**
**Для чего применяется метод Array.from()?**
**Назовите способы преобразования массива в объект?**
**Разница между Object и Map?**
**Что такое каррирование?**
**Для чего используются метод Object.seal()?**
**Для чего используется свойство .dataset?**
**Каким образом можно обмениваться кодом между файлами?**
**Как работает «сборщик мусора» в JavaScript?**
**Что такое утечки памяти?**
**Назовите основные типы утечек памяти в JavaScript?**
**Как работает контекст выполнения (execution context) в JavaScript?**
**Разница между примитивом и объектом?**