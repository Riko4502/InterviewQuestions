<h3>
  <span>JavaScript:</span>
</h3>

**Типы данных в JavaScript?**

- Примитивные типы данных: 
    1. string (строка), 
    2. number (число), 
    3. boolean (логический тип), 
    4. null (отсутствие значения), 
    5. undefined (значение не определено), 
    6. symbol (уникальный и неизменяемый идентификатор).
- Ссылочные типы данных: 
  1. object (объект), включая массивы, функции и объекты Date.

**Разница между == и === (нестрогое/строгое равенство)?**

- **==** выполняет нестрогое сравнение, преобразуя типы данных при необходимости.
- **===** выполняет строгое сравнение, сравнивая значения и типы данных без преобразования.

**Что такое Strict mode в JavaScript?**

**Strict mode** — это режим, в котором код выполняется в более строгом режиме, обеспечивая более точную семантику языка.

Включение строгого режима осуществляется с помощью директивы "**use strict**"; в начале скрипта или функции.
Строгий режим активизирует некоторые новые возможности языка, исправляет ошибки и запрещает использование некоторых потенциально опасных конструкций.

**Разница между function declaration и function expression?**

**Function declaration** (объявление функции) начинается с ключевого слова function и имеет имя функции.
**Function expression** (функциональное выражение) создается путем присваивания функции переменной или использования ее в качестве значения выражения.

```
// Function Declaration
function sum(a, b) {
  return a + b;
}

// Function Expression
var sum = function(a, b) {
  return a + b;
}
```

Основная разница заключается в том, что function declarations создаются до выполнения кода (во время поднятия), а function expressions создаются во время выполнения кода.

**Разница между null и undefined?**

**null** используется для обозначения отсутствия значения или пустого объекта.
**undefined** используется для обозначения переменной, которая была объявлена, но ей не было присвоено значения, или для параметра функции, которому не было передано значение.

**Типы таймеров в JavaScript?**

**setTimeout** выполняет функцию один раз через указанный интервал времени.
**setInterval** выполняет функцию периодически через указанный интервал времени.
**requestAnimationFrame** используется для выполнения анимации и планирования обновлений экрана на основе частоты обновления браузера.

**Что такое поднятие (Hoisting)?**

Поднятие — это механизм в JavaScript, который перемещает объявления переменных и функций вверх в их область видимости перед выполнением кода.
В результате поднятия можно обращаться к переменным и функциям до их фактического объявления в коде.

**Что такое область видимости (Scope)?**

Область видимости определяет доступность переменных, объектов и функций в определенной части кода.
Глобальная область видимости — это доступность по всему коду.
Локальная область видимости — это доступность только внутри определенной функции или блока кода.

**Разница между var, let и const?**
Функциональная область видимости:
**var** — ключевое слово для объявления переменных со значением, видимым внутри функции или глобальной области видимости.

Блочная область видимости:
**let**— ключевое слово для объявления переменных со значением, видимым внутри блока кода, в котором они объявлены.
**const** — ключевое слово для объявления переменных со значением, которое не может быть изменено после присваивания. Константы должны быть инициализированы при объявлении.

**Что такое замыкание (Closure)?**

**Замыкание** — это комбинация функции и лексического окружения, в котором эта функция была объявлена.
Замыкание позволяет функции сохранять доступ к переменным из своего внешнего лексического окружения, даже после того, как это окружение было выполнено.

**Что обозначает this в JavaScript?**

Ключевое слово **this** в JavaScript ссылается на текущий контекст выполнения.
Значение **this** зависит от того, как функция была вызвана: как метод объекта, как функция конструктора, как метод объекта с использованием **call** или **apply**, или в **глобальной области видимости**.

**Что такое функции высшего порядка (Higher Order Functions)?**

Функции высшего порядка — это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результата.
Функции высшего порядка позволяют создавать абстракции и компоненты для повторного использования кода.

**Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?**

Для преобразования любого типа данных в булевый (логический) тип можно использовать логическое отрицание **!!**.
Ложные (**falsy**) значения в JavaScript: **false, 0, "" (пустая строка), null, undefined, NaN**.

**Методы строк в JavaScript?**

- **length** — возвращает длину строки.
- **charAt(index)** — возвращает символ по указанному индексу.
- **concat(...strings)** — объединяет строки.
- **indexOf(searchValue[, fromIndex])** — возвращает индекс первого вхождения заданного значения.
- **substring(startIndex[, endIndex])** — возвращает подстроку с указанными индексами начала и конца.
и другие методы: **toUpperCase(), toLowerCase(), split(), trim(), replace(), startsWith(), endsWith()** и т.д.

**Методы массивов в JavaScript?**

- **length** — возвращает длину массива.
- **push(...items)** — добавляет элементы в конец массива.
- **pop()** — удаляет и возвращает последний элемент массива.
- **shift()**— удаляет и возвращает первый элемент массива.
- **unshift(...items)** — добавляет элементы в начало массива.
- **concat(...arrays)** — объединяет массивы.
и другие методы: **join(), slice(), splice(), reverse(), sort(), indexOf(), lastIndexOf(), forEach(), map(), filter(), reduce()** и т.д.


**Что такое чистая функция?**

**Чистая функция** — это функция, которая возвращает результат только на основе своих аргументов без побочных эффектов.
Чистая функция не изменяет внешнее состояние и не взаимодействует с внешними ресурсами.

**Разница между .forEach() и .map()?**

**.forEach()** вызывает переданную функцию для каждого элемента массива, но не возвращает новый массив.
.map() вызывает переданную функцию для каждого элемента массива и возвращает новый массив, состоящий из результатов вызовов функции.

**Разница между .call(), .apply() и bind()?**

**.call()** и **.apply()** используются для вызова функции с явным указанием контекста (значения **this**) и передачей аргументов.
Разница между **.call()** и **.apply()** заключается в способе передачи аргументов: **.call()** принимает аргументы через запятую, а **.apply()** принимает аргументы в виде массива.
**.bind()** создает новую функцию, привязывая указанный контекст (значение **this**) и, при необходимости, предварительно заданные аргументы.

**Почему в JS функции называют объектами первого класса?**

Потому, что они могут быть:
- Присвоены переменной.
- Использованы как аргументы для других функций.
- Возвращены из других функций.
- Хранены в структурах данных, например, в массивах или объектах.

**Как определить наличие свойства в объекте?**

Для проверки наличия свойства в объекте можно использовать оператор in или метод hasOwnProperty().

Пример с использованием оператора in:

```
const obj = { prop: 'value' };

if ('prop' in obj) {
  console.log('Свойство "prop" существует в объекте');
}
```

Пример с использованием метода **hasOwnProperty()**:

```
const obj = { prop: 'value' };

if (obj.hasOwnProperty('prop')) {
  console.log('Свойство "prop" существует в объекте');
}
```

**Что такое IIFE?**

IIFE (Immediately Invoked Function Expression) — это функция, которая вызывается немедленно после своего определения. Она часто используется для создания локальной области видимости и изоляции переменных от глобального контекста. IIFE обычно создается в виде анонимной функции, которая затем вызывается с помощью оператора вызова ().

Пример IIFE:

```
(function() {
  // Код IIFE
})();

```

**Что такое псевдомассив arguments?**

Псевдомассив arguments — это объект, доступный внутри функции, который содержит все аргументы, переданные функции при её вызове. arguments имеет свойства, похожие на элементы массива, но он не является полноценным массивом, поскольку не имеет методов массива.

**Разница между host-объектами и нативными объектами?**

В контексте JavaScript host-объекты — это объекты, предоставляемые средой выполнения (например, браузером или Node.js) и доступные в глобальной области видимости. Они могут включать объекты, такие как window (в браузере) или global (в Node.js), а также другие объекты, предоставляемые средой выполнения.

Нативные объекты, с другой стороны, это объекты, предоставляемые самим языком JavaScript. Они включают в себя объекты, такие как Array, Object, Function и т.д.

**Почему результат сравнения 2х объектов это false?**

Результат сравнения двух объектов ({}) будет false, потому что операторы сравнения (== и ===) для объектов сравнивают ссылки на объекты, а не их содержимое. Два объекта с разными ссылками будут считаться разными объектами, даже если они имеют одинаковую структуру и значения свойств.

**Что такое прототипное наследование? Как создать объект без прототипа?**

Прототипное наследование — это механизм наследования в JavaScript, где объект может наследовать свойства и методы от другого объекта, называемого прототипом. Прототипы в JavaScript образуют цепочку, которая позволяет объектам наследовать свойства и методы от прототипов своих прототипов.

Для создания объекта без прототипа можно использовать функцию Object.create(null). Это создаст объект, у которого нет прототипа и не наследует свойства и методы от других объектов.

Пример создания объекта без прототипа:

```
const objWithoutPrototype = Object.create(null);
```

**Почему расширение нативных JavaScript-объектов это плохая практика?**

Расширение нативных JavaScript-объектов, добавление новых методов или свойств к встроенным объектам (например, Array, String, Object), считается плохой практикой по нескольким причинам:

- Возможность конфликтов имён: расширение нативных объектов может привести к конфликтам имён с будущими версиями языка или другими библиотеками.
- Непредсказуемое поведение: расширение нативных объектов может изменить их поведение в неожиданный способ, что может затруднить отладку и поддержку кода.
- Портабельность: код, который расширяет нативные объекты, может не работать в других средах выполнения или старых версиях JavaScript.

**Что такое NaN? Как определить, что значение равно NaN?**

NaN (Not-a-Number) — это специальное значение в JavaScript, которое указывает на то, что результат математической операции не является числом. Например, деление нуля на ноль или попытка преобразования некорректной строки в число может дать NaN.

Чтобы определить, что значение равно NaN, можно использовать функцию isNaN() или оператор Number.isNaN().

Пример использования isNaN():

```
isNaN(NaN); // true
isNaN(10); // false
```
Пример использования Number.isNaN():

```
Number.isNaN(NaN); // true
Number.isNaN(10); // false
```

**Что такое объектная обертка (Wrapper Objects)?**

Объектные обертки (Wrapper Objects) в JavaScript предоставляют возможность работать с примитивными типами (Number, String, Boolean) как с объектами. Это означает, что к примитивным значениям можно применять методы, которые предоставляют объектные обертки.

Например:

```
const str = 'Hello';
const strWrapper = new String(str);

console.log(str.length); // 5
console.log(strWrapper.length); // 5
```

В данном примере strWrapper является объектной оберткой для примитивного значения строки str.

**Как в JavaScript создать объект?**

В JavaScript объекты можно создать с помощью литерала объекта {} или с использованием конструктора new Object().

Примеры:

```
// Литерал объекта
const obj1 = {};

// Конструктор Object()
const obj2 = new Object();
```

Можно также создать объект с начальными свойствами и значениями с помощью литерала объекта или метода Object.create().

Примеры:

```
// Литерал объекта с начальными свойствами
const obj3 = { prop1: 'value1', prop2: 'value2' };

// Object.create()
const obj4 = Object.create(null);
```

**Для чего используется ключевое слово new?**

Ключевое слово new используется для создания экземпляра объекта, используя конструктор функцию. При использовании new, функция-конструктор вызывается с новым пустым объектом в качестве контекста выполнения (this), и этот объект становится результатом операции new.

Пример:

```
function Person(name) {
  this.name = name;
}

const john = new Person('John');
console.log(john.name); // 'John'
```

В приведенном примере **new Person('John')** создает новый объект, на который ссылается **this** внутри **функции-конструктора Person**, и устанавливает свойство name этого объекта в **'John'**.

**Операторы «И» и «ИЛИ» (&& и ||)?**

Оператор && (логическое И) возвращает первый операнд, если он приводится к логическому значению false, в противном случае возвращает второй операнд. Оператор || (логическое ИЛИ) возвращает первый операнд, если он приводится к логическому значению true, в противном случае возвращает второй операнд.

Примеры:

```
const a = 10;
const b = 20;
const c = null;
const d = 'Hello';

console.log(a && b); // 20, так как оба операнда истинны
console.log(a && c); // null, так как первый операнд ложный
console.log(c && d); // null, так как первый операнд ложный

console.log(a || b); // 10, так как первый операнд истинный
console.log(a || c); // 10, так как первый операнд истинный
console.log(c || d); // 'Hello', так как оба операнда ложные
```

Обратите внимание, что операторы && и || выполняют ленивую оценку, что означает, что второй операнд не вычисляется, если его значение не влияет на результат операции.

**Для чего используется оператор двойного отрицания (!!)?**

Оператор двойного отрицания (!!) используется для преобразования значения в логический тип данных (true или false). Он применяется к значению и выполняет следующие действия:

Если значение является ложным (например, false, null, undefined, 0, NaN, пустая строка), то оператор !! преобразует его в false.
Если значение является истинным (любое значение, отличное от ложных значений), то оператор !! преобразует его в true.
При использовании оператора двойного отрицания, результатом будет всегда логическое значение true или false. Это может быть полезно, когда необходимо проверить и привести значение к логическому типу данных.

Примеры:

```
console.log(!!true);      // true
console.log(!!false);     // false
console.log(!!0);         // false
console.log(!!1);         // true
console.log(!!null);      // false
console.log(!!undefined); // false
console.log(!!'');        // false
console.log(!!'hello');   // true
console.log(!!{});        // true
console.log(!![]);        // true
```

В примере выше, оператор !! используется для преобразования различных значений в логические значения.

**Для чего используется оператор остатка (%)?**

Оператор остатка (%) используется для получения остатка от деления двух чисел. Например, выражение a % b вернет остаток от деления числа a на число b. Оператор остатка полезен, когда требуется выполнить определенные действия в зависимости от четности или нечетности числа или когда нужно проверить делимость одного числа на другое.

**Как проверить, является ли значение массивом?**

В JavaScript можно использовать метод **Array.isArray()** для проверки, является ли значение массивом. Этот метод возвращает **true**, если переданное значение является массивом, и **false** в противном случае. 
Пример использования:

```
const value = [1, 2, 3];
console.log(Array.isArray(value)); // true

const anotherValue = 'Hello';
console.log(Array.isArray(anotherValue)); // false
```

**Как работает boxing/unboxing в JavaScript?**

Boxing и unboxing в JavaScript связаны с преобразованием примитивных типов данных в объекты и обратно.

Boxing (также называемый "упаковкой") происходит, когда примитивное значение (например, число, строка или булево значение) используется как объект. JavaScript автоматически создает объект-обертку для примитивного значения, чтобы можно было вызывать методы и использовать свойства объекта.

Unboxing (также называемый "распаковкой") происходит, когда объект-обертка преобразуется обратно в примитивное значение. JavaScript автоматически извлекает значение из объекта-обертки, когда это значение требуется для выполнения операции.

Примеры:

```
// Boxing
const number = 42; // примитивное число
const numberObject = new Number(number); // объект-обертка

console.log(number.toFixed(2)); // Метод toFixed() работает благодаря автоматическому boxing

// Unboxing
const stringObject = new String('Hello'); // объект-обертка
const string = stringObject.valueOf(); // распаковка в примитивное значение

console.log(string.toUpperCase()); // Метод toUpperCase() работает после распаковки
```

**Что такое мемоизация? Реализуйте базовую логику функции для мемоизации?**

Мемоизация - это оптимизационная техника, которая заключается в сохранении результатов выполнения функции для заданных входных данных, чтобы избежать повторных вычислений при последующих вызовах функции с теми же входными данными. Это особенно полезно, когда функция является ресурсоемкой или часто вызывается с одними и теми же аргументами.

Вот пример базовой реализации функции для мемоизации:

```
function memoize(func) {
  const cache = {}; // Кеш для хранения результатов выполнения функции

  return function (...args) {
    const key = JSON.stringify(args); // Создаем ключ на основе аргументов функции

    if (cache[key]) {
      return cache[key]; // Возвращаем сохраненное значение из кеша
    }

    const result = func.apply(this, args); // Выполняем функцию

    cache[key] = result; // Сохраняем результат выполнения в кеше

    return result; // Возвращаем результат
  };
}

// Пример использования

function calculateFactorial(n) {
  console.log(`Calculating factorial of ${n}...`);
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * calculateFactorial(n - 1);
}

const memoizedFactorial = memoize(calculateFactorial);

console.log(memoizedFactorial(5)); // Первый вызов - вычисляется и кешируется
console.log(memoizedFactorial(5)); // Второй вызов - результат берется из кеша
console.log(memoizedFactorial(3)); // Новый аргумент - вычисляется и кешируется
console.log(memoizedFactorial(3)); // Результат берется из кеша
```



**Разница между оператором in и методом .hasOwnProperty()?**

Оператор **in** и метод **.hasOwnProperty()** в JavaScript используются для проверки наличия свойства в объекте, но имеют некоторые различия.

Оператор **in** проверяет наличие свойства не только в самом объекте, но и в его прототипе. Если свойство найдено в прототипе, оператор **in** вернет **true**. 

Пример:

```
const obj = { foo: 'bar' };

console.log('foo' in obj); // true

// Создаем объект с прототипом obj
const objWithPrototype = Object.create(obj);
console.log('foo' in objWithPrototype); // true
```

Метод **.hasOwnProperty()** проверяет наличие свойства только в самом объекте, игнорируя его прототип. Если свойство найдено в прототипе, **.hasOwnProperty()** вернет **false**. 

Пример:

```
const obj = { foo: 'bar' };

console.log(obj.hasOwnProperty('foo')); // true

// Создаем объект с прототипом obj
const objWithPrototype = Object.create(obj);
console.log(objWithPrototype.hasOwnProperty('foo')); // false
```

**Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?**

Глубокая (deep) копия объекта создает полностью независимую копию, включая все вложенные объекты и массивы. Изменения, внесенные в оригинальный объект или его копию, не будут влиять друг на друга.

Поверхностная (shallow) копия объекта создает новый объект, но ссылки на вложенные объекты и массивы остаются общими для оригинала и его копии. Изменения внутри вложенных объектов или массивов будут видны как в оригинале, так и в его копии.

Вот примеры, как можно создать глубокую и поверхностную копии объекта:

Глубокая копия:

```
const obj = { a: 1, b: { c: 2 } };

// Способ 1: Рекурсивное клонирование объекта
const deepCopy1 = JSON.parse(JSON.stringify(obj));

// Способ 2: Использование библиотеки lodash
const deepCopy2 = _.cloneDeep(obj);
```

Поверхностная копия:

```
const obj = { a: 1, b: { c: 2 } };

// Способ 1: Использование Object.assign()
const shallowCopy1 = Object.assign({}, obj);

// Способ 2: Использование расширения объекта
const shallowCopy2 = { ...obj };
```

**Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?**

Цепочка вызовов функций (chaining) - это подход, при котором методы вызываются последовательно на одном объекте, а результат каждого метода становится доступным для вызова следующего метода. Это позволяет сократить код и сделать его более читабельным.

Для реализации цепочки вызовов функций, каждый метод должен возвращать объект, на котором он вызывается. Это достигается путем возврата ссылки на текущий объект (this) в конце каждого метода.

Вот пример, демонстрирующий реализацию цепочки вызовов функций:

```
class Calculator {
  constructor() {
    this.value = 0;
  }

  add(num) {
    this.value += num;
    return this; // Возвращаем ссылку на текущий объект
  }

  subtract(num) {
    this.value -= num;
    return this; // Возвращаем ссылку на текущий объект
  }

  multiply(num) {
    this.value *= num;
    return this; // Возвращаем ссылку на текущий объект
  }

  divide(num) {
    this.value /= num;
    return this; // Возвращаем ссылку на текущий объект
  }
}

const calculator = new Calculator();
const result = calculator.add(5).multiply(2).subtract(3).divide(2);
console.log(result.value); // 4
```

В этом примере можно видеть, как методы add(), multiply(), subtract(), divide() последовательно вызываются на объекте calculator, а результат каждого метода становится доступным для вызова следующего метода.

**Что такое необъявленная переменная?**

Необъявленная переменная - это переменная, на которую обращаются без предварительного объявления с помощью ключевых слов var, let или const. При обращении к необъявленной переменной она становится глобальной переменной, если она не находится в строгом режиме ("use strict"), в противном случае будет выброшено исключение.

**Как передаются параметры в функцию: по ссылке или по значению?**

Параметры передаются в функцию по значению. Это означает, что копия значения аргумента передается в параметр функции, и любые изменения параметра не влияют на значение аргумента за пределами функции. Однако, если аргументом является объект или массив, то копия ссылки на объект передается в параметр, поэтому изменения объекта внутри функции будут видны за её пределами.

**Что такое прототип объекта в JavaScript?**

Прототип объекта в JavaScript - это механизм, который позволяет объектам наследовать свойства и методы от других объектов. Каждый объект имеет ссылку на свой прототип, и если свойство или метод не найдены в самом объекте, они ищутся в цепочке прототипов, пока не будет найдено соответствующее значение или будет достигнут конечный прототип Object.prototype.

**Как работает метод Object.create()?**

Метод Object.create() используется для создания нового объекта с указанным прототипом. Он принимает первым параметром объект, который будет использоваться в качестве прототипа для создаваемого объекта. Второй необязательный параметр позволяет определить дескрипторы свойств нового объекта.

**Разниц между Object.freeze() и Object.seal()?**

Object.freeze() и Object.seal() - это методы для ограничения изменений объектов в JavaScript. Object.freeze() делает объект полностью неизменяемым, запрещая добавление, удаление или изменение свойств объекта. Object.seal() запрещает добавление или удаление свойств объекта, но позволяет изменять существующие свойства.

**Разница между методами .slice() и .splice()?**

Методы .slice() и .splice() используются для работы с массивами. .slice() создаёт новый массив, содержащий выбранные элементы из исходного массива, без изменения последнего. Он принимает два параметра - индексы начала и конца выбранной части массива. .splice() изменяет исходный массив, удаляя, заменяя или добавляя элементы. Он принимает три параметра - индекс начала изменения, количество удаляемых элементов и, при необходимости, элементы, которые следует добавить.

**Как работают методы .find(), .findIndex() и .indexOf()?**

Методы .find(), .findIndex() и .indexOf() используются для поиска элементов в массиве. 
- .find() возвращает первый элемент, удовлетворяющий заданному условию проверки (функции обратного вызова). 
- .findIndex() возвращает индекс первого элемента, удовлетворяющего условию проверки. 
- .indexOf() возвращает индекс первого вхождения указанного элемента в массиве.

**Плюсы и минусы использования use strict?**

Использование директивы "use strict" (строгий режим) имеет следующие плюсы: включает более строгую проверку синтаксиса, запрещает использование некоторых устаревших или опасных конструкций, предотвращает случайное создание глобальных переменных, улучшает производительность. Минусы: может вызывать ошибки, если используется несовместимый с ним код, требует более точного написания кода.

**Разница между методами .push(), .pop(), .shift() и .unshift()?**

Методы .push(), .pop(), .shift() и .unshift() используются для изменения массива. .push() добавляет один или несколько элементов в конец массива и возвращает новую длину массива. .pop() удаляет последний элемент массива и возвращает его значение. .shift() удаляет первый элемент массива и сдвигает остальные элементы влево, возвращая удаленное значение. .unshift() добавляет один или несколько элементов в начало массива и возвращает новую длину массива.

**Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?**

Иммутабельность означает, что объекты не могут быть изменены после их создания. Плюсы: облегчает отладку и понимание кода, позволяет легче разделять данные между различными частями программы, облегчает реализацию некоторых оптимизаций и повышает производительность. Достичь иммутабельности в JavaScript можно, например, используя методы и операторы, которые возвращают новые объекты вместо изменения существующих, или с помощью библиотек, таких как Immutable.js.

**Типы всплывающих окон в JavaScript?**

В JavaScript есть несколько типов всплывающих окон: alert(), confirm() и prompt().
- alert() выводит сообщение и ожидает, пока пользователь нажмет кнопку "OK". 
- confirm() выводит сообщение и ожидает, пока пользователь нажмет кнопку "OK" или "Отмена", возвращая соответствующее значение (true или false). 
- prompt() выводит сообщение и ожидает, пока пользователь введет текст или нажмет кнопку "OK" или "Отмена", возвращая введенный текст или null.

**Типы объектов JavaScript?**

В JavaScript есть различные типы объектов, включая: 
- Object (обычные объекты), 
- Array (массивы), 
- Function (функции), 
- Date (даты), 
- RegExp (регулярные выражения), 
- Math (математические операции), 
- Map (карты), 
- Set (множества) и другие.

**Парадигмы программирования в JavaScript?**

В JavaScript применяются различные парадигмы программирования, включая процедурное программирование, объектно-ориентированное программирование (ООП) и функциональное программирование.

**Типы ошибок в JavaScript?**

В JavaScript есть различные типы ошибок, включая 
- синтаксические ошибки (ошибки, возникающие из-за неправильного синтаксиса кода), 
- ошибки времени выполнения (ошибки, возникающие при выполнении кода) и 
- ошибки логики программы (ошибки, связанные с неправильным логическим выводом или алгоритмом).

**Разница между typeof и instanceof?**

- typeof - оператор, который возвращает тип операнда в виде строки. 
- instanceof - оператор, который проверяет, принадлежит ли объект к определенному классу или типу.

**JavaScript статически, или динамически типизированный язык?**

JavaScript является динамически типизированным языком программирования. 
Это означает, что переменные могут содержать значения разных типов данных, и их типы могут быть изменены во время выполнения программы.

**Что такое регулярное выражение (Regular Expression)?**

Регулярное выражение (Regular Expression) - это шаблон для поиска и сопоставления текста в строке. 
Он используется для выполнения операций поиска и замены, валидации данных и других манипуляций с текстом.

**Что такое рекурсия?**

Рекурсия - это процесс, когда функция вызывает саму себя в своем теле. 
Рекурсия может использоваться для решения задач, которые могут быть выражены в терминах более простых версий этой же задачи.

**Что такое прототип (Prototype) объекта?**

Прототип (Prototype) объекта - это объект, который используется в качестве шаблона для создания других объектов. 
Объекты в JavaScript могут наследовать свойства и методы от своих прототипов.

**Какие методы используются в регулярных выражениях?**

В регулярных выражениях используются различные методы, включая .test(), .exec(), .match(), .search(), .replace(), .split() и другие. Каждый метод выполняет определенную операцию со строкой, используя регулярное выражение.

**Что такое полифил (polyfill)?**

Полифил (polyfill) - это код, который предоставляет реализацию функциональности, которая отсутствует или не полностью поддерживается в текущей версии языка или среде выполнения. 
Полифилы обычно используются для обеспечения совместимости с более старыми версиями языка или для добавления новых возможностей в старые версии.

**Что такое switch/case? Правила использования switch/case?**

switch/case - это конструкция в языке программирования, которая позволяет выполнить различный набор инструкций в зависимости от значения выражения. Она позволяет упростить код, который выполняет множество условных проверок. 
Правила использования switch/case включают использование оператора break для остановки выполнения после соответствующего блока case и использование блока default для задания действий по умолчанию.

**Типы функций по способности принимать другие функции?**

Функции могут принимать другие функции в качестве параметров или возвращать функции в качестве результата. Такие функции называются функциями **высшего порядка** или **функциями первого класса**.

**Что такое выражения (expression) и инструкции (statement) в JavaScript?**

Выражение (expression) - это фрагмент кода, который вычисляется в значение. Он может быть переменной, операцией, вызовом функции и т. д. Инструкция (statement) - это фрагмент кода, который выполняет определенное действие. Он может быть присваиванием значения, вызовом функции, условным оператором и т. д.

**Разница между .some() и .every()?**

Методы .some() и .every() используются для проверки условий в массиве. .some() возвращает true, если хотя бы один элемент массива удовлетворяет условию проверки. 
- .every() возвращает true, если все элементы массива удовлетворяют условию проверки.

**Как сгенерировать случайное число в JavaScript?**

Для генерации случайного числа в JavaScript можно использовать метод **Math.random()**, который возвращает случайное число в диапазоне от 0 (включительно) до 1 (исключительно). Для получения случайного числа в определенном диапазоне можно использовать формулу **Math.random() * (max - min) + min**.

**Типы операторов в JavaScript?**

В JavaScript есть различные типы операторов:
- включая арифметические 
- сравнения
- логические
- присваивания
- условные и другие. 
Операторы используются для выполнения различных операций над значениями.

**Разница между параметром и аргументом функции?**

Параметр функции - это переменная, которая определена в объявлении функции и используется для передачи значения в функцию при ее вызове. Аргумент функции - это значение, переданное в функцию при ее вызове.

**Правила задания имён для переменных и функций в JavaScript?**

В JavaScript существуют некоторые правила для задания имён переменных и функций. Имена могут содержать буквы (в верхнем или нижнем регистре), цифры, символы $ и _. Они должны начинаться с буквы, символа $ или символа _. Имена чувствительны к регистру и не могут совпадать с зарезервированными ключевыми словами языка.

**Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?**

- Явное преобразование (Explicit Coercion) - это преобразование значения одного типа в другой тип с использованием явно указанных операторов или функций. 
- Неявное преобразование (Implicit Coercion) - это автоматическое преобразование значения одного типа в другой тип JavaScript во время выполнения операций.

**Для чего применяется метод Array.from()?**

Метод Array.from() используется для создания нового массива из массивоподобного или итерируемого объекта. 
Он преобразует каждый элемент объекта в элемент нового массива.

**Назовите способы преобразования массива в объект?**

Способы преобразования массива в объект включают использование методов Object.assign() и Array.reduce(), а также прямое создание объекта с помощью цикла или метода Object.fromEntries().

**Разница между Object и Map?**

Object и Map - это два разных типа объектов в JavaScript. Object - это встроенный тип объекта, который используется для хранения коллекции пар ключ-значение. 
Map - это тип объекта, предоставляемый стандартной библиотекой JavaScript (ES6), который предоставляет более мощные возможности для хранения и манипулирования данными в виде коллекции пар ключ-значение.

**Что такое каррирование?**

Каррирование (Currying) - это процесс преобразования функции с несколькими аргументами в последовательность функций, каждая из которых принимает только один аргумент. 
Это позволяет создавать новые функции, частично применяя аргументы к исходной функции.

**Для чего используются метод Object.seal()?**

Метод Object.seal() используется для запрета добавления новых свойств в объект, а также для установки флага writable в false для существующих свойств. Существующие свойства могут быть изменены, но нельзя добавлять или удалять свойства.

**Для чего используется свойство .dataset?**

Свойство .dataset предоставляет доступ к набору пользовательских атрибутов данных (data-атрибутов) на элементе. Оно представляет собой объект, содержащий все атрибуты данных элемента, и позволяет получать и устанавливать значения этих атрибутов.

**Каким образом можно обмениваться кодом между файлами?**

Для обмена кодом между файлами в JavaScript можно использовать различные методы, включая импорт и экспорт модулей (стандарт ES6), использование соглашений о именовании глобальных объектов и использование библиотек и фреймворков для работы с зависимостями.

**Как работает «сборщик мусора» в JavaScript?**

Сборщик мусора (Garbage Collector) - это часть среды выполнения JavaScript, которая автоматически освобождает память, занятую объектами, которые больше не используются в программе. Сборщик мусора отслеживает объекты, на которые больше нет ссылок, и удаляет их из памяти.

**Что такое утечки памяти?**

Утечки памяти (Memory Leaks) - это ситуации, когда память, выделенная для объектов в программе, не освобождается после того, как эти объекты больше не нужны. Утечки памяти могут привести к увеличению потребления памяти и снижению производительности программы.

**Назовите основные типы утечек памяти в JavaScript?**

Основные типы утечек памяти в JavaScript включают циклические ссылки, незавершенные таймеры и интервалы, неправильное использование замыканий, глобальные переменные и неправильное управление памятью в библиотеках и фреймворках.

**Как работает контекст выполнения (execution context) в JavaScript?**

Контекст выполнения (Execution Context) в JavaScript - это внутренняя структура данных, которая содержит информацию о переменных, функциях, текущем местоположении выполнения кода и других деталях выполнения программы.

**Разница между примитивом и объектом?**

Примитивы - это базовые типы данных в JavaScript, включающие числа, строки, логические значения (true и false), null и undefined. 
Они представляют простые значения и не имеют свойств и методов. Объекты - это более сложные типы данных, которые могут содержать свойства и методы.
