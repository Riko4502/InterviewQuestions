<h3>
  <span>React:</span>
</h3>

**Что такое React?**

React - это JavaScript библиотека для разработки пользовательских интерфейсов.

**Перечислите особенности React?**

Особенности React: виртуальный DOM, компонентный подход, однонаправленный поток данных, повторное использование компонентов, JSX синтаксис.

**Что такое Virtual DOM? Как он работает с React?**

Виртуальный DOM - это копия реального DOM, которая хранится в памяти и обновляется эффективным образом при изменениях данных. React использует виртуальный DOM для оптимизации процесса рендеринга и обновления компонентов.

**Для чего нужен атрибут key при рендере списков?**

Атрибут key используется при рендере списков в React для идентификации уникальных элементов. Он помогает React определить, какие элементы были добавлены, изменены или удалены, и эффективно обновить только необходимые части интерфейса.

**Что такое PureComponent?**

PureComponent - это базовый компонент React, который реализует метод shouldComponentUpdate с автоматической проверкой на изменение пропсов и состояния компонента. Если изменений нет, PureComponent предотвращает повторный рендеринг компонента для оптимизации производительности.

**Что такое Компонент высшего порядка (Higher-Order Component/HOC)?**

Компонент высшего порядка (Higher-Order Component/HOC) - это функция, которая принимает компонент и возвращает новый компонент с дополнительным функционалом или оберткой.

**Разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?**

Управляемые компоненты (controlled components) связаны с состоянием через пропсы и обновляются исключительно на основе изменений входных данных. Неуправляемые компоненты (uncontrolled components) хранят свое состояние внутри себя и обновляют DOM напрямую.

**Методы жизненного цикла компонента в React?**

Методы жизненного цикла компонента в React: componentDidMount, componentDidUpdate, componentWillUnmount и другие. Однако, в новых версиях React, использование хуков является более предпочтительным способом для работы с жизненным циклом компонента.

**Стадии жизненного цикла компонента в React?**

Стадии жизненного цикла компонента в React: монтирование (mounting), обновление (updating) и размонтирование (unmounting).

**Что такое React Reconciliation?**

React Reconciliation (согласование) - это процесс сравнения старого и нового состояния компонента, который позволяет React определить эффективные обновления и минимизировать манипуляции с DOM.

**Что такое портал (Portal)?**

Портал (Portal) - это механизм в React, который позволяет рендерить компоненты в DOM-узлы, которые находятся вне иерархии компонентов.

**Что такое контекст (Context)?**

Контекст (Context) в React представляет собой механизм, позволяющий передавать данные глубоко вниз по иерархии компонентов без явной передачи пропсов через каждый промежуточный компонент. Он используется для обмена данными между компонентами, которым необходим доступ к определенным данным или функциональности. Контекст позволяет избежать "пробрасывания" пропсов через несколько уровней компонентов и упрощает передачу данных, таких как локализация, тема оформления и аутентификация.

**Что такое React хуки (Hooks)?**

React хуки (Hooks) - это новое дополнение к React 16.8, которое позволяет использовать состояние и другие возможности React в функциональных компонентах. Ранее, до появления хуков, функциональные компоненты в React использовались только для простых компонентов без состояния (state). Хуки позволяют функциональным компонентам иметь состояние, использовать методы жизненного цикла, обрабатывать события и многое другое. Некоторые из наиболее распространенных хуков в React включают useState, useEffect, useContext, useReducer и useMemo.

**Что Такое JSX?**

JSX (JavaScript XML) - это расширение языка JavaScript, которое позволяет писать HTML-подобный синтаксис прямо внутри кода JavaScript. Он используется в React для описания структуры пользовательского интерфейса. JSX преобразуется компилятором Babel в вызовы функций React.createElement, которые создают виртуальное представление элементов интерфейса в виде дерева компонентов.

**Разница между состоянием(state) и пропсами(props)?**

Состояние (state) и пропсы (props) являются двумя основными концепциями в React для управления и передачи данных в компонентах.

Состояние (state) представляет данные, которые управляются и обновляются внутри компонента. Оно является внутренним для компонента и может быть изменено с использованием метода setState(). Состояние может быть локальным для компонента или разделено между несколькими компонентами через поднятие состояния вверх (lifting state up).

Пропсы (props) представляют данные, которые передаются компоненту из внешнего источника. Они являются неизменяемыми и только для чтения внутри компонента. Пропсы передаются от родительского компонента дочернему компоненту и могут быть использованы для настройки поведения и отображения компонента.

**Что такое React Fiber?**

React Fiber - это новый движок виртуального DOM, который был представлен в React 16. Это переработанная внутренняя архитектура React, разработанная для обеспечения более высокой производительности, более плавной анимации и возможности приостанавливать, прерывать и возобновлять процесс рендеринга компонентов.

React Fiber представляет собой новый способ организации работы React. Он разбивает процесс рендеринга на более мелкие, приоритетные задачи, которые могут выполняться поэтапно и позволяют React эффективно управлять приоритетами, прерывать и возобновлять рендеринг и обрабатывать большие приложения с высокой производительностью.

**Что такое фрагмент (Fragment)? Почему фрагмент лучше, чем div?**

Фрагмент (Fragment) - это компонент в React, который позволяет группировать список дочерних элементов без создания лишнего уровня DOM-узлов. Он представляет собой виртуальный контейнер, который не создает дополнительные DOM-элементы в итоговом дереве компонентов.

Фрагменты полезны, когда вам нужно возвращать несколько элементов из компонента, но вы не хотите оборачивать их в дополнительный DOM-элемент, такой как div. Использование фрагментов помогает уменьшить влияние на структуру HTML-разметки и может повысить производительность.

**Что такое синтетические события в React?**

Синтетические события (Synthetic Events) в React - это перехватываемые и обрабатываемые версии браузерных событий, предоставляемые React для обработки событий в компонентах. Они являются обертками вокруг нативных браузерных событий и предоставляют унифицированный кросс-браузерный интерфейс для работы с событиями.

Синтетические события предоставляют дополнительную функциональность, такую как нормализация различий между браузерами, делегирование событий, предотвращение поведения по умолчанию и передача дополнительных данных. Они используются в React для обработки пользовательских событий, таких как клики, изменения значений полей ввода, наведение курсора и многое другое.

**Что такое React-ссылка (ref)? Как создать ссылку?**

React-ссылка (ref) - это механизм, позволяющий получить доступ к DOM-узлу или экземпляру компонента, созданному React. Он используется для изменения состояния и свойств компонента, вызова методов компонента или получения информации о DOM-элементе.

Для создания ссылки в React можно использовать функцию React.createRef() вместе с атрибутом ref в компоненте. Например:

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }

  componentDidMount() {
    this.myRef.current.focus();
  }

  render() {
    return <input ref={this.myRef} />;
  }
}
```

В приведенном примере this.myRef создается в конструкторе компонента с использованием React.createRef(). Затем ссылка присваивается в атрибут ref элемента <input>. После монтирования компонента метод componentDidMount() вызывается, и фокус устанавливается на элемент <input>, используя ссылку this.myRef.current.

**Разница между теневым (Shadow) и виртуальным (Virtual) DOM?**

Теневой (Shadow) DOM и виртуальный (Virtual) DOM - это два разных концепта в веб-разработке, и оба они используются в React, хотя имеют разные цели и применения:

Виртуальный DOM - это концепция, при которой React создает в памяти виртуальное представление DOM-дерева для отслеживания изменений и эффективного обновления реального DOM. Виртуальный DOM позволяет React сравнить предыдущее и текущее состояние виртуального дерева и определить минимальное количество фактических изменений, которые необходимо внести в реальный DOM для обновления пользовательского интерфейса. Это улучшает производительность, так как минимизируются непосредственные манипуляции с реальным DOM, которые являются ресурсоемкими.

Теневой DOM - это механизм, предоставляемый браузером, который позволяет изолировать и ограничить стили и сценарии компонента или компонентов на странице. Теневой DOM используется для создания компонентов, которые имеют свои собственные стили и сценарии, независимые от остальной страницы. Он позволяет ограничивать воздействие стилей и сценариев на компоненты и обеспечивает их инкапсуляцию.

Вкратце, виртуальный DOM используется для оптимизации обновлений реального DOM, а теневой DOM используется для изоляции стилей и сценариев компонентов.

**Назовите преимущества использования React?**

Виртуальный DOM: React использует виртуальный DOM, что позволяет эффективно обновлять только необходимые части интерфейса, минимизируя количество реальных изменений в DOM и повышая производительность.

Компонентный подход: React основан на компонентах, которые позволяют разбить пользовательский интерфейс на небольшие, независимые и повторно используемые блоки. Это упрощает разработку, тестирование и поддержку кода.

Односторонний поток данных: В React данные передаются от родительских компонентов к дочерним, что упрощает отслеживание изменений и обновление интерфейса.

JSX: React использует JSX, синтаксическое расширение JavaScript, которое позволяет писать HTML-подобный код внутри JavaScript. Это делает код более читабельным и позволяет разработчикам легко комбинировать логику и представление.

Большое сообщество и экосистема: React имеет активное сообщество разработчиков, что обеспечивает доступ к множеству дополнительных библиотек, инструментов и ресурсов для обучения.

**Что такое условный рендеринг (Conditional Rendering)? Как его выполнить?**

Условный рендеринг (Conditional Rendering) - это механизм в React, который позволяет выбирать, какие компоненты или элементы следует отображать на основе условия или значения переменной. Можно использовать условные операторы (например, if-else или тернарный оператор) или логические выражения для определения, какой контент нужно отобразить в зависимости от определенных условий.

Пример условного рендеринга с использованием тернарного оператора:

```
function App() {
  const isLoggedIn = true;

  return (
    <div>
      {isLoggedIn ? <Home /> : <Login />}
    </div>
  );
}
```

В данном примере, если **isLoggedIn** равно true, будет отображен компонент <Home />, в противном случае будет отображен компонент <Login />.

**Что такое компонент-переключатель (Switching Component)?**

Компонент-переключатель (Switching Component) - это компонент, который отображает только один из своих дочерних компонентов в зависимости от некоторого условия. Вместо отображения всех дочерних компонентов, компонент-переключатель выбирает и отображает только один из них.

Пример компонента-переключателя:

```
function SwitchingComponent({ condition }) {
  return (
    <div>
      {condition ? <ComponentA /> : <ComponentB />}
    </div>
  );
}
```

В данном примере, если condition равно true, будет отображен компонент <ComponentA />, в противном случае будет отображен компонент <ComponentB />.

**Разница между React и ReactDOM?**

React - это библиотека для создания пользовательских интерфейсов. Она предоставляет основные функции и классы, такие как компоненты, виртуальный DOM и механизм рендеринга.
ReactDOM - это пакет, который содержит специфичные для веб-платформы методы, необходимые для рендеринга React-компонентов в реальный DOM. Он предоставляет методы для монтирования (render), обновления и размонтирования компонентов в DOM.

**Разница между компонентом и контейнером?**

Компонент (Component) - это независимый и повторно используемый блок, который содержит логику и представление для отображения определенного элемента интерфейса.
Контейнер (Container) - это компонент, который обычно используется для организации и управления состоянием и передачи данных другим компонентам. Контейнеры не заботятся о визуальном представлении, они фокусируются на управлении данными и передаче их дочерним компонентам.

**Как React обрабатывает, или ограничивает использование пропсов определенного типа?**

React обрабатывает или ограничивает использование пропсов определенного типа с помощью механизма проверки типов (Type Checking). Один из распространенных инструментов для этого - PropTypes, который позволяет определить типы ожидаемых пропсов для компонентов. С помощью PropTypes можно задать ожидаемый тип пропса (например, строка, число, объект и т.д.) и дополнительные условия, такие как обязательность пропса или ограничения значений.

Пример использования PropTypes:

```
import PropTypes from 'prop-types';

function MyComponent(props) {
  // ...
}

MyComponent.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
  email: PropTypes.string
};
```

В этом примере name - обязательный пропс типа string, age - необязательный пропс типа number, email - пропс типа string.

**Что такое строгий режим в React? Его преимущества?**

Строгий режим (Strict Mode) в React — это инструмент разработки, который позволяет выявить потенциальные проблемы и ошибки в приложении, делая их более заметными и предупреждая о них в консоли разработчика. Он предназначен для использования во время разработки, а не в продакшн-среде.

Преимущества строгого режима:

Обнаружение проблем: Строгий режим помогает обнаружить и предупредить о некоторых типичных проблемах, таких как устаревшие методы жизненного цикла, нестабильные изменения состояния и нежелательные побочные эффекты.

Предупреждения о потенциальных проблемах: Строгий режим генерирует дополнительные предупреждения, которые помогают выявить и исправить проблемы, такие как использование устаревших API, неоптимальные практики и потенциальные проблемы производительности.

Обнаружение нежелательных побочных эффектов: Строгий режим помогает выявить нежелательные побочные эффекты, такие как изменение состояния компонента во время его рендеринга, что может привести к непредсказуемому поведению.

Важно отметить, что строгий режим не изменяет поведение самого приложения в продакшн-среде. Он предназначен для облегчения разработки и повышения качества кода.

**Что такое «бурение пропсов» (Prop Drilling)? Как его избежать?**

"Бурение пропсов" (Prop Drilling) — это ситуация, когда пропсы передаются через несколько уровней компонентов, чтобы достичь конечного компонента, который их фактически использует. Это может приводить к неудобству и избыточности кода.

Чтобы избежать "бурения пропсов" и сделать передачу данных более эффективной, в React можно использовать контекст (Context) или Redux.

Контекст (Context): Контекст позволяет передавать значение глубоко вниз по дереву компонентов без явной передачи через каждый промежуточный компонент. Вы можете создать контекст с помощью функции createContext из пакета react и предоставить значение контекста вверху иерархии компонентов, а затем использовать его в нужных компонентах с помощью useContext или Consumer.

Redux: Redux — это библиотека управления состоянием, которая позволяет централизованно хранить и обновлять состояние приложения. Она предоставляет глобальное хранилище, из которого компоненты могут получать нужные данные, а также диспетчеры для изменения состояния. С помощью Redux можно избежать "бурения пропсов", так как данные доступны через глобальное хранилище без необходимости передачи их через каждый компонент в иерархии.

Выбор между контекстом и Redux зависит от сложности и масштаба вашего приложения. В случае простых сценариев контекст может быть достаточным, в то время как Redux предоставляет более мощные инструменты для управления состоянием в сложных приложениях.

**Что такое «опрос» (Polling)? Как его реализовать в React?**

**Опрос** (Polling) — это техника, при которой клиентский код периодически отправляет запросы на сервер для получения обновленных данных.

В React опрос можно реализовать с помощью хука **useEffect** и функции **setInterval**. Вот пример простой реализации опроса в React:

```
import React, { useState, useEffect } from 'react';

function DataComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch('https://api.example.com/data');
      const newData = await response.json();
      setData(newData);
    };

    const intervalId = setInterval(fetchData, 5000); // Опрос каждые 5 секунд

    return () => {
      clearInterval(intervalId); // Остановка опроса при размонтировании компонента
    };
  }, []);

  return (
    <div>
      {data ? (
        <div>{data}</div>
      ) : (
        <div>Loading...</div>
      )}
    </div>
  );
}
```

В этом примере компонент DataComponent использует хук **useEffect** для запуска функции **fetchData** с помощью **setInterval** каждые 5 секунд. Затем полученные данные сохраняются в состояние с помощью **setData**.

Возвращаемая функция из **useEffect** выполняется при размонтировании компонента и очищает интервал с помощью **clearInterval**, чтобы остановить опрос.

**Разница между элементом и компонентом?**

В терминах React:

Элемент (element) — это простой объект JavaScript, который описывает компонент или DOM-элемент, который должен быть отображен в дереве компонентов. Элементы можно создавать с помощью функции **React.createElement** или JSX-синтаксиса. 
Например:
```
const element = <div>Hello, World!</div>;
```

Компонент (component) — это функция или класс, которая может принимать входные данные (пропсы) и возвращать элементы, которые должны быть отображены. Компоненты являются основными строительными блоками приложения на React. Компоненты можно создавать как функциональные компоненты с помощью функций или как классовые компоненты, наследующие от базового класса React.Component. Например:
```
// Функциональный компонент
function Greeting(props) {
  return <div>Hello, {props.name}!</div>;
}

// Классовый компонент
class Greeting extends React.Component {
  render() {
    return <div>Hello, {this.props.name}!</div>;
  }
}
```

В обоих случаях компонент **Greeting** принимает пропс **name** и возвращает элемент **<div>**, отображающий приветствие с указанным именем.

Компоненты могут быть использованы в других компонентах и комбинированы для создания сложных интерфейсов.

**Что такое ReactDOMServer?**

ReactDOMServer — это модуль, предоставляемый React, который позволяет рендерить React-компоненты в строку или статический HTML на стороне сервера.

Этот модуль предоставляет ряд методов, таких как **renderToString** и **renderToStaticMarkup**, которые принимают React-компонент и возвращают соответствующую строку или HTML-разметку.

**renderToString(component)** возвращает строку, содержащую HTML-разметку для переданного React-компонента. Эта строка может быть отправлена на клиент и вставлена в DOM с помощью JavaScript.

**renderToStaticMarkup(component)** возвращает строку, содержащую HTML-разметку для переданного React-компонента без оборачивающего контейнера. Этот метод полезен, когда вам не нужны лишние обертки вокруг корневого элемента.

Пример использования ReactDOMServer:

```
import ReactDOMServer from 'react-dom/server';

const element = <div>Hello, World!</div>;
const html = ReactDOMServer.renderToString(element);

console.log(html); // "<div data-reactroot>Hello, World!</div>"
```

В этом примере компонент **<div>Hello, World!</div>** рендерится в строку с помощью **ReactDOMServer.renderToString** и результат сохраняется в переменной **html**. Затем строка **html** может быть отправлена на клиент или использована для других целей на стороне сервера.

**Что такое предохранители (Error Boundaries)?**

Предохранители (Error Boundaries) — это компоненты React, которые позволяют обработать ошибки, которые могут возникнуть в дочерних компонентах во время рендеринга, жизненного цикла или обработки событий. Они позволяют отделить ошибки внутри компонента от остальной части приложения, предотвращая поломку всего приложения и предоставляя возможность показать пользователю информацию об ошибке или выполнить альтернативные действия.

Чтобы создать предохранитель, необходимо определить компонент с методом **componentDidCatch(error, info)**, который будет вызываться, когда происходит ошибка в любом дочернем компоненте. Этот метод принимает два аргумента: **error** — объект ошибки, и **info** — объект, содержащий информацию о компоненте, в котором произошла ошибка.

Пример предохранителя:

```
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  componentDidCatch(error, info) {
    this.setState({ hasError: true });
    console.error(error);
    // Можно выполнить дополнительные действия, например, отправить отчет об ошибке
  }

  render() {
    if (this.state.hasError) {
      return <div>Что-то пошло не так. Пожалуйста, обновите страницу.</div>;
    }
    return this.props.children;
  }
}
```

В этом примере компонент **ErrorBoundary** является предохранителем. Если в дочерних компонентах происходит ошибка, метод **componentDidCatch** будет вызван, устанавливая состояние **hasError** в **true**. Затем компонент рендерит соответствующий контент в зависимости от состояния.

Чтобы использовать предохранитель, оберните им нужные компоненты:

```
<ErrorBoundary>
  <Component1 />
  <Component2 />
</ErrorBoundary>
```

Теперь, если произойдет ошибка в **Component1** или **Component2**, предохранитель будет перехватывать ошибку и показывать соответствующее сообщение.

**Что такое «ленивая» (Lazy) функция?**

"Ленивая" (Lazy) функция — это функция, которая используется для динамической загрузки компонентов в React. Она позволяет разделить код приложения на более мелкие части и загружать их по требованию, тем самым улучшая начальную производительность приложения.

Ленивая загрузка компонентов осуществляется с помощью функции **React.lazy**, которая принимает функцию импорта компонента и возвращает промис, который разрешается при загрузке компонента.

Пример использования "ленивой" функции:
```
import React, { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => import('./LazyComponent'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
```

В этом примере компонент **LazyComponent** загружается лениво с помощью **React.lazy** и **import**. Оборачивание LazyComponent в компонент **Suspense** позволяет определить фолбек (заглушку), которая отображается во время загрузки компонента.

**Разница между рендерингом и монтированием?**

В контексте React:

Рендеринг (rendering) — это процесс преобразования компонента или элемента React в соответствующее представление в виде виртуального DOM или реального DOM. Рендеринг происходит, когда React обновляет отображение компонента в результате изменения его состояния или пропсов. Он выполняется с помощью метода **render** в функциональных компонентах или с помощью метода **render** или **return** в классовых компонентах.

Монтирование (mounting) — это процесс добавления компонента в дерево компонентов и внедрение его в реальный DOM. Монтирование происходит при первоначальном отображении компонента. Во время монтирования вызываются методы жизненного цикла, такие как **constructor**, **componentDidMount** и другие. Во время этого процесса компонент получает доступ к DOM-узлам и может выполнять инициализацию или подписываться на события.

Таким образом, рендеринг — это процесс обновления отображения компонента, а монтирование — это процесс добавления компонента в дерево компонентов и его инициализации.

**Что такое сhildren?**

Children (дети) — это специальное свойство, доступное в компонентах React, которое позволяет передавать вложенные элементы или компоненты в компоненты-контейнеры. Children является неявным пропсом и может содержать любые дочерние элементы, включая текст, другие компоненты или фрагменты.

Children можно использовать в компонентах для отображения, манипулирования или передачи дочерних элементов внутрь других компонентов. Свойство children обычно передается как аргумент или доступно через **props.children** в функциональных компонентах или **this.props.children** в классовых компонентах.

Пример использования children:

```
function Container({ children }) {
  return <div className="container">{children}</div>;
}

function App() {
  return (
    <Container>
      <h1>Hello, World!</h1>
      <p>This is a paragraph.</p>
    </Container>
  );
}
```

В этом примере компонент **Container** принимает свойство **children** и отображает его внутри **<div className="container">**. В компоненте App дочерние элементы **<h1>** и **<p>** передаются в **Container** как **children** и отображаются внутри него.

**Что такое события указателя (Pointer Events)?**

События указателя (Pointer Events) — это набор событий в браузере, которые отслеживают действия пользователя с помощью указателя, такого как мышь, сенсорный экран или стилус. События указателя позволяют реагировать на различные действия пользователя, такие как клик, перемещение, наведение и другие.

React поддерживает события указателя, предоставляя соответствующие обработчики событий в компонентах. Некоторые из этих обработчиков событий указателя в React включают:

- **onPointerDown**: событие возникает, когда пользователь нажимает на указатель (например, клик мышью).
- **onPointerUp**: событие возникает, когда пользователь отпускает указатель после нажатия.
- **onPointerMove**: событие возникает, когда указатель перемещается.
- **onPointerEnter**: событие возникает, когда указатель входит в пределы элемента.
- **onPointerLeave**: событие возникает, когда указатель покидает пределы элемента.
и другие.

Пример использования обработчика события указателя:

```
function handleClick(event) {
  console.log('Clicked!', event);
}

function App() {
  return <div onPointerDown={handleClick}>Click me</div>;
}
```

В этом примере обработчик события **handleClick** привязывается к событию onPointerDown элемента **<div>**. При клике на этот элемент в консоль будет выведено сообщение **"Clicked!"** и объект события указателя.

**Что такое инверсия наследования (Inheritance Inversion)?**



**Как в React реализовать двустороннее связывание данных?**



**Разница между классовым и функциональным компонентами?**



**Разница между useEffect() и componentDidMount()?**



**Преимущества хуков?**



**Недостатки хуков?**



**Правила (ограничения) использования хуков?**


**Что такое поднятие состояния вверх (Lifting State Up)?**



**Что делает метод shouldComponentUpdate?**



**Разница между createElement() и cloneElement()?**



**Что такое useReducer()?**



**Как реализовать однократное выполнение операции при начальном рендеринге?**



**Что такое распределенный компонент?**



**Расскажите о хуках useCallback(), useMemo(), useImperativeHandle(), useLayoutEffect()?**



**Как отрендерить HTML код в React-компоненте?**



**Зачем в setState() нужно передавать функцию?**



**Для чего предназначен метод registerServiceWorker() в React?**



**Чем React Router отличается от обычной маршрутизации?**



**Какие хуки были добавлены в React Router версии 5?**



**Как передавать пропсы в React Router?**



**Что такое Reselect и как он работает?**



**Назовите основную цель React Fiber?**



**Какие типы данных может возвращать render?**



**Разница между memo и useMemo?**



**Что такое синтетические события (SyntheticEvent) в React?**



**Является ли React реактивным?**



**Техники оптимизации перфоманса React?**



**Лучшие практики безопасности в React?**


