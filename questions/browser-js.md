<h3>
  <span>JS in Browser:</span>
</h3>

**Что такое DOM?**

DOM (Document Object Model) - это программное представление структуры HTML-документа, которое позволяет программистам взаимодействовать с элементами веб-страницы. DOM представляет документ в виде дерева, где каждый узел представляет собой элемент, атрибут, текстовый фрагмент или другой тип данных.

**Типы узлов DOM-дерева?**

Типы узлов DOM-дерева включают:

- Элементы (Element Node) - представляют HTML-элементы на странице, например, `<div>` или `<p>`.
- Текстовые узлы (Text Node) - содержат текстовое содержимое элемента.
- Комментарии (Comment Node) - содержат комментарии в HTML-коде.
- Атрибуты (Attribute Node) - представляют атрибуты элементов.
- Другие типы узлов, такие как документ (Document Node), документ фрагмента (Document Fragment Node) и т.д.

**Методы поиска элементов в DOM?**

- getElementById(id) - возвращает элемент по его уникальному идентификатору.
- getElementsByTagName(tagName) - возвращает коллекцию элементов с заданным тегом.
- getElementsByClassName(className) - возвращает коллекцию элементов с заданным классом.
- querySelector(selector) - возвращает первый элемент, соответствующий заданному селектору CSS.
- querySelectorAll(selector) - возвращает все элементы, соответствующие заданному селектору CSS.

**Свойства для перемещения по DOM-дереву?**

- parentNode - возвращает родительский элемент текущего узла.
- childNodes - возвращает коллекцию дочерних узлов текущего узла.
- firstChild - возвращает первый дочерний узел текущего узла.
- lastChild - возвращает последний дочерний узел текущего узла.
- nextSibling - возвращает следующий узел на том же уровне дерева.
- previousSibling - возвращает предыдущий узел на том же уровне дерева.

**Разница между attribute и property у DOM-элементов?**

Атрибуты (attribute) определяют начальное значение свойств элемента и могут быть заданы в HTML-коде. Они представляют собой строковые значения и могут быть получены или изменены с помощью JavaScript с использованием методов, таких как getAttribute() и setAttribute().

Свойства (property) представляют текущее состояние элемента и могут быть получены или изменены с помощью JavaScript. Свойства являются более нативными для JavaScript и обычно имеют типы данных, отличные от строк, в зависимости от конкретного свойства элемента. Например, свойство value для элемента input является свойством, представляющим текущее значение ввода, в то время как атрибут value определяет начальное значение элемента.

**Что такое BOM?**

BOM (Browser Object Model) - это программный интерфейс, предоставляемый браузером, который позволяет JavaScript взаимодействовать с браузером и его окружением (например, окнами, фреймами, историей браузера и т.д.). BOM не является частью стандарта DOM, но предоставляет дополнительные возможности для работы с браузером.

**Виды событий в JavaScript?**

1. События мыши: click, mouseover, mouseout и т.д.
2. События клавиатуры: keydown, keyup, keypress и т.д.
3. События формы: submit, focus, blur и т.д.
4. События документа: load, DOMContentLoaded, unload и т.д.
5. События анимации и перехода: animationstart, transitionend и т.д.
6. События Drag and Drop: dragstart, dragend, drop и т.д.

**Как добавить обработчик события на DOM-элемент?**

Для добавления обработчика события на DOM-элемент можно использовать метод addEventListener(). 
Например:

```
const button = document.getElementById('myButton');
button.addEventListener('click', function() {
  console.log('Button clicked!');
});
```

**Как удалить обработчик события с DOM-элемента?**

Для удаления обработчика события с DOM-элемента можно использовать метод removeEventListener(). Обработчик должен быть функцией, объявленной отдельно, чтобы его можно было удалить. 
Например:

```
const button = document.getElementById('myButton');
const handleClick = function() {
  console.log('Button clicked!');
};

button.addEventListener('click', handleClick);

// Удаление обработчика
button.removeEventListener('click', handleClick);
```

**Что такое распространение события (Event Propagation)?**

Распространение события (Event Propagation) - это механизм, при котором событие, возникающее на элементе, передается через его родительские элементы или дочерние элементы вверх или вниз по дереву DOM. Распространение события происходит в двух фазах: фаза захвата (capture) и фаза всплытия (bubbling).

**Что такое делегирование событий (Event Delegation)?**

Делегирование событий (Event Delegation) - это техника, при которой обработчик события добавляется к общему родительскому элементу, вместо прямого добавления обработчика к каждому дочернему элементу. Когда происходит событие, оно всплывает по иерархии элементов, и обработчик на родительском элементе может отреагировать на событие в дочерних элементах.

**Как использовать media выражения в JavaScript?**

Для использования media выражений в JavaScript можно использовать объект window.matchMedia(). Этот метод позволяет проверить, соответствует ли текущее окно или документ определенному медиа-запросу.
Например:

```
const mediaQuery = window.matchMedia('(max-width: 768px)');

if (mediaQuery.matches) {
  // Код, который выполняется при совпадении медиа-запроса
} else {
  // Код, который выполняется при несовпадении медиа-запроса
}
```

**Расскажите про координаты в браузере?**

Координаты в браузере могут быть представлены как относительные (относительно текущего элемента) или абсолютные (относительно документа или окна).

Относительные координаты:
- clientX, clientY - координаты относительно окна браузера.
- offsetX, offsetY - координаты относительно элемента, на котором произошло событие.
- pageX, pageY - координаты относительно документа, учитывая прокрутку страницы.

Абсолютные координаты:
- screenX, screenY - координаты относительно экрана пользователя.

**Разница между HTMLCollection и NodeList?**

HTMLCollection и NodeList - это коллекции элементов, которые могут быть получены с помощью методов DOM. 
Однако есть некоторые различия:

HTMLCollection:
- Является "живым" коллекцией, что означает, что она автоматически обновляется при изменении DOM.
- Возвращается методами, такими как getElementsByTagName() и getElementsByClassName().
- Предоставляет только некоторые методы и свойства, такие как length и item().

NodeList:
- Также является "живой" коллекцией, но некоторые реализации могут предоставлять "статический" NodeList, который не обновляется автоматически.
- Возвращается методами, такими как querySelectorAll() или свойством childNodes.
- Предоставляет больше методов и свойств, таких как forEach(), entries(), итератор и др.

**Как динамически добавить элемент на HTML-страницу?**

Для динамического добавления элемента на HTML-страницу можно использовать методы DOM, такие как createElement() для создания нового элемента и appendChild() или insertBefore() для добавления элемента в определенное место в DOM-дереве.

Например:
```
const newElement = document.createElement('div');
newElement.textContent = 'Новый элемент';

const parentElement = document.getElementById('parent');
parentElement.appendChild(newElement);
```

**Разница между feature detection, feature inference и анализом строки user-agent?**

Разница между feature detection, feature inference и анализом строки user-agent:

Feature detection - это техника проверки наличия поддержки определенных функций, методов или свойств в браузере перед их использованием. Это позволяет программе адаптироваться к возможностям браузера и предотвращает возникновение ошибок в случае отсутствия поддержки.

Пример:
```
if (typeof window.localStorage !== 'undefined') {
  // Браузер поддерживает localStorage
  // Код для работы с localStorage
} else {
  // Браузер не поддерживает localStorage
  // Альтернативный код или сообщение для пользователя
}
```

Feature inference - это техника, при которой предполагается наличие определенной функциональности на основе другой функциональности, которая уже была проверена. Например, если браузер поддерживает определенный метод, можно предположить, что он также поддерживает связанные с ним методы. Однако это может быть ненадежным предположением.

Анализ строки user-agent - это метод определения браузера и его версии на основе информации, содержащейся в строке user-agent, которая отправляется браузером на сервер. Это устаревший подход и не рекомендуется для определения возможностей браузера, так как user-agent может быть легко поддельным или измененным.

**Разница между e.preventDefault() и e.stopPropagation()?**

- e.preventDefault() используется в обработчике событий для отмены действия по умолчанию, которое обычно происходит в результате события. Например, при клике на ссылку e.preventDefault() предотвратит переход по ссылке.
- e.stopPropagation() используется для остановки распространения события по иерархии DOM. Если вызвано e.stopPropagation(), событие не будет передано к другим элементам внутри иерархии DOM.


**Разница между event.target и event.currentTarget?**

- **event.target** содержит ссылку на элемент, на котором произошло событие.
- **event.currentTarget** содержит ссылку на элемент, на котором сработал текущий обработчик события. В случае использования делегирования событий, **event.currentTarget** будет ссылаться на родительский элемент, к которому привязан обработчик, даже если событие произошло на его потомке.

**Разница между .stopPropagation() и .stopImmediatePropagation()?**

- **.stopPropagation()** предотвращает дальнейшее всплытие события вверх по иерархии DOM. Другие обработчики на текущем элементе будут вызваны, но событие не будет передано выше.
- **.stopImmediatePropagation()** делает то же самое, что и .stopPropagation(), но также предотвращает вызов любых остальных обработчиков события на текущем элементе. Дополнительные обработчики событий, привязанные к тому же элементу, не будут вызваны.

**Разница между событиями load и DOMContentLoaded?**

- **load** событие срабатывает, когда все ресурсы на странице, такие как изображения и стили, полностью загружены.
- **DOMContentLoaded** событие срабатывает, когда структура DOM документа полностью построена и доступна, но до окончания загрузки всех внешних ресурсов (например, изображений).

**Сколько аргументов принимает addEventListener?**

Метод **addEventListener** принимает три аргумента:
Тип события, на которое нужно прослушивать (например, '**click**' или '**keydown**').
Функцию-обработчик, которая будет вызываться при срабатывании события.
Необязательный третий аргумент, **useCapture**, который указывает, должен ли обработчик сработать в фазе перехвата (если **true**) или в фазе всплытия (если **false**, значение по умолчанию).

**Разница между innerHTML и outerHTML?**

- innerHTML содержит HTML-код всех дочерних элементов указанного элемента. Это свойство можно использовать для получения или изменения содержимого элемента.
- outerHTML содержит HTML-код самого элемента и его содержимого. Если изменить значение outerHTML, элемент будет полностью заменен новым HTML-кодом.

**Разница между JSON и XML?**

- JSON (JavaScript Object Notation) является форматом обмена данными, основанным на синтаксисе JavaScript. Он прост в использовании, легковесный и хорошо подходит для представления структурированных данных, таких как объекты и массивы.
- XML (eXtensible Markup Language) является языком разметки, который позволяет определять собственные теги для описания структурированных данных. XML более гибок, чем JSON, и обычно используется для обмена данными между различными платформами и языками программирования.

**Как узнать об использовании метода event.preventDefault()?**

Чтобы узнать об использовании метода event.preventDefault(), можно посмотреть на код обработчика события и найти место, где вызывается event.preventDefault(). Обычно это делается для предотвращения стандартного поведения элемента или предотвращения отправки формы.

**Для чего используется свойство window.navigator?**

Свойство window.navigator используется для получения информации о браузере и операционной системе, на которых выполняется код. Оно предоставляет различные свойства и методы для получения такой информации, например, navigator.userAgent возвращает строку, содержащую информацию о браузере и версии.

**Для чего используется метод .focus()?**

Метод .focus() используется для установки фокуса на указанный элемент на веб-странице. Когда элемент получает фокус, он может принимать пользовательский ввод, например, при нажатии клавиш или вводе текста.

**Для чего используется свойство .forms?**

Свойство **.forms** предоставляет доступ к коллекции всех форм, содержащихся внутри элемента `<form>` или `<fieldset>`. Это свойство позволяет получить доступ к формам и их элементам, чтобы манипулировать ими или получать информацию о введенных данных.

**Для чего используется метод .scrollIntoView()?**

Метод **.scrollIntoView()** используется для прокрутки содержимого страницы или контейнера так, чтобы указанный элемент стал видимым в окне просмотра. Когда вызывается этот метод, браузер прокручивает страницу таким образом, чтобы элемент стал видимым на экране, если это возможно.

**Разница между методами .submit() и .requestSubmit()?**

- .submit() вызывает событие отправки формы, что приводит к отправке данных формы на сервер.
- .requestSubmit() отправляет форму на сервер так, как если бы пользователь нажал на кнопку отправки формы. Этот метод позволяет запустить валидацию формы перед отправкой и обработать возможные ошибки, прежде чем отправить данные.

**Расскажите о IntersectionObserver?**

IntersectionObserver - это API, которое позволяет отслеживать видимость элементов на странице при прокрутке или изменении размера окна браузера. Он предоставляет эффективный способ обнаружения и реагирования на пересечение элементов с определенной областью видимости (например, видимость внутри определенного контейнера или на экране).

**Расскажите о URLSearchParams?**

URLSearchParams - это встроенный объект JavaScript, который предоставляет удобные методы для работы с параметрами URL. Он позволяет извлекать, добавлять, изменять и удалять параметры из URL-строки. 
URLSearchParams облегчает манипуляции с параметрами URL без необходимости ручного разбора и создания строк URL.

**Какие есть ограничения у window.close()?**

- В большинстве современных браузеров он может закрыть только окна, которые были открыты с помощью JavaScript с использованием метода window.open(). Он не может закрыть основное окно браузера или окно, которое было открыто без использования JavaScript.
- Браузеры могут блокировать вызов window.close(), если он вызывается не в результате пользовательского действия, например, внутри обработчика события, вызванного асинхронно.
- В режиме защищенного просмотра или приложения, где окно было открыто в другом контексте, вызов window.close() может быть заблокирован.